// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/test_messages_proto2.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnumProto2 = "FOREIGN_FOO" | "FOREIGN_BAR" | "FOREIGN_BAZ";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 *
 * Also, crucially, all messages and enums in this file are eventually
 * submessages of this message.  So for example, a fuzz test of TestAllTypes
 * could trigger bugs that occur in any message type in this file.  We verify
 * this stays true in a unit test.
 */
export interface TestAllTypesProto2 {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypesProto2.NestedMessage;
  optionalForeignMessage: ForeignMessageProto2;
  optionalNestedEnum: TestAllTypesProto2.NestedEnum;
  optionalForeignEnum: ForeignEnumProto2;
  optionalStringPiece: string;
  optionalCord: string;
  recursiveMessage: TestAllTypesProto2 | null | undefined;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypesProto2.NestedMessage[];
  repeatedForeignMessage: ForeignMessageProto2[];
  repeatedNestedEnum: TestAllTypesProto2.NestedEnum[];
  repeatedForeignEnum: ForeignEnumProto2[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  /**
   * Packed
   */
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedNestedEnum: TestAllTypesProto2.NestedEnum[];
  /**
   * Unpacked
   */
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedNestedEnum: TestAllTypesProto2.NestedEnum[];
  /**
   * Map
   */
  mapInt32Int32: Record<
    string,
    TestAllTypesProto2.MapInt32Int32["value"] | undefined
  >;
  mapInt64Int64: Record<
    string,
    TestAllTypesProto2.MapInt64Int64["value"] | undefined
  >;
  mapUint32Uint32: Record<
    string,
    TestAllTypesProto2.MapUint32Uint32["value"] | undefined
  >;
  mapUint64Uint64: Record<
    string,
    TestAllTypesProto2.MapUint64Uint64["value"] | undefined
  >;
  mapSint32Sint32: Record<
    string,
    TestAllTypesProto2.MapSint32Sint32["value"] | undefined
  >;
  mapSint64Sint64: Record<
    string,
    TestAllTypesProto2.MapSint64Sint64["value"] | undefined
  >;
  mapFixed32Fixed32: Record<
    string,
    TestAllTypesProto2.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestAllTypesProto2.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestAllTypesProto2.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestAllTypesProto2.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<
    string,
    TestAllTypesProto2.MapInt32Float["value"] | undefined
  >;
  mapInt32Double: Record<
    string,
    TestAllTypesProto2.MapInt32Double["value"] | undefined
  >;
  mapBoolBool: Record<
    string,
    TestAllTypesProto2.MapBoolBool["value"] | undefined
  >;
  mapStringString: Record<
    string,
    TestAllTypesProto2.MapStringString["value"] | undefined
  >;
  mapStringBytes: Record<
    string,
    TestAllTypesProto2.MapStringBytes["value"] | undefined
  >;
  mapStringNestedMessage: Record<
    string,
    TestAllTypesProto2.MapStringNestedMessage["value"] | undefined
  >;
  mapStringForeignMessage: Record<
    string,
    TestAllTypesProto2.MapStringForeignMessage["value"] | undefined
  >;
  mapStringNestedEnum: Record<
    string,
    TestAllTypesProto2.MapStringNestedEnum["value"] | undefined
  >;
  mapStringForeignEnum: Record<
    string,
    TestAllTypesProto2.MapStringForeignEnum["value"] | undefined
  >;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypesProto2.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
  oneofBool?: boolean | null | undefined;
  oneofUint64?: bigint | null | undefined;
  oneofFloat?: number | null | undefined;
  oneofDouble?: number | null | undefined;
  oneofEnum?: TestAllTypesProto2.NestedEnum | null | undefined;
  defaultInt32: number;
  /**
   * default values
   */
  defaultInt64: bigint;
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  fieldname1: number;
  /**
   * Test field-name-to-JSON-name convention.
   * (protobuf says names can be any valid C/C++ identifier.)
   */
  fieldName2: number;
  fieldName3: number;
  fieldName4: number;
  field0name5: number;
  field0Name6: number;
  fieldName7: number;
  FieldName8: number;
  fieldName9: number;
  FieldName10: number;
  FIELDNAME11: number;
  FIELDName12: number;
  fieldName13: number;
  FieldName14: number;
  fieldName15: number;
  fieldName16: number;
  fieldName17: number;
  FieldName18: number;
}

export declare namespace TestAllTypesProto2 {
  export type NestedEnum = "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    a: number;
    corecursive: TestAllTypesProto2 | null | undefined;
  }

  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapStringBytes {
    key: string;
    value: Uint8Array;
  }

  interface MapStringNestedMessage {
    key: string;
    value: TestAllTypesProto2.NestedMessage;
  }

  interface MapStringForeignMessage {
    key: string;
    value: ForeignMessageProto2;
  }

  interface MapStringNestedEnum {
    key: string;
    value: TestAllTypesProto2.NestedEnum;
  }

  interface MapStringForeignEnum {
    key: string;
    value: ForeignEnumProto2;
  }

  /**
   * groups
   */
  export interface Data {
    groupInt32: number;
    groupUint32: number;
  }

  /**
   * message_set test case.
   */
  export interface MessageSetCorrect {}

  export interface MessageSetCorrectExtension1 {
    str: string;
  }

  export interface MessageSetCorrectExtension2 {
    i: number;
  }
}

export interface ForeignMessageProto2 {
  c: number;
}

export interface UnknownToTestAllTypes {
  optionalInt32: number;
  optionalString: string;
  nestedMessage: ForeignMessageProto2;
  optionalBool: boolean;
  repeatedInt32: number[];
}

export declare namespace UnknownToTestAllTypes {
  export interface OptionalGroup {
    a: number;
  }
}

export interface NullHypothesisProto2 {}

export interface EnumOnlyProto2 {}

export declare namespace EnumOnlyProto2 {
  export type Bool = "kFalse" | "kTrue";
}

export interface OneStringProto2 {
  data: string;
}

export interface ProtoWithKeywords {
  inline: number;
  concept: string;
  requires: string[];
}

export interface TestAllRequiredTypesProto2 {
  /**
   * Singular
   */
  requiredInt32: number;
  requiredInt64: bigint;
  requiredUint32: number;
  requiredUint64: bigint;
  requiredSint32: number;
  requiredSint64: bigint;
  requiredFixed32: number;
  requiredFixed64: bigint;
  requiredSfixed32: number;
  requiredSfixed64: bigint;
  requiredFloat: number;
  requiredDouble: number;
  requiredBool: boolean;
  requiredString: string;
  requiredBytes: Uint8Array;
  requiredNestedMessage: TestAllRequiredTypesProto2.NestedMessage;
  requiredForeignMessage: ForeignMessageProto2;
  requiredNestedEnum: TestAllRequiredTypesProto2.NestedEnum;
  requiredForeignEnum: ForeignEnumProto2;
  requiredStringPiece: string;
  requiredCord: string;
  recursiveMessage: TestAllRequiredTypesProto2 | null | undefined;
  optionalRecursiveMessage: TestAllRequiredTypesProto2 | null | undefined;
  defaultInt32: number;
  /**
   * default values
   */
  defaultInt64: bigint;
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
}

export declare namespace TestAllRequiredTypesProto2 {
  export type NestedEnum = "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    a: number;
    corecursive: TestAllRequiredTypesProto2 | null | undefined;
    optionalCorecursive: TestAllRequiredTypesProto2 | null | undefined;
  }

  /**
   * groups
   */
  export interface Data {
    groupInt32: number;
    groupUint32: number;
  }

  /**
   * message_set test case.
   */
  export interface MessageSetCorrect {}

  export interface MessageSetCorrectExtension1 {
    str: string;
  }

  export interface MessageSetCorrectExtension2 {
    i: number;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnumProto2 = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnumProto2 {
    switch (i) {
      case 0: {
        return "FOREIGN_FOO";
      }
      case 1: {
        return "FOREIGN_BAR";
      }
      case 2: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnumProto2;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnumProto2): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 0;
      }
      case "FOREIGN_BAR": {
        return 1;
      }
      case "FOREIGN_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesProto2 = {
  /**
   * Serializes TestAllTypesProto2 to protobuf.
   */
  encode: function (msg: PartialDeep<TestAllTypesProto2>): Uint8Array {
    return TestAllTypesProto2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypesProto2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypesProto2 {
    return TestAllTypesProto2._readMessage(
      TestAllTypesProto2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestAllTypesProto2 with all fields set to their default value.
   */
  initialize: function (): TestAllTypesProto2 {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesProto2.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageProto2.initialize(),
      optionalNestedEnum: TestAllTypesProto2.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnumProto2._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      recursiveMessage: undefined,
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedNestedEnum: [],
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedNestedEnum: [],
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapStringBytes: {},
      mapStringNestedMessage: {},
      mapStringForeignMessage: {},
      mapStringNestedEnum: {},
      mapStringForeignEnum: {},
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
      oneofBool: undefined,
      oneofUint64: undefined,
      oneofFloat: undefined,
      oneofDouble: undefined,
      oneofEnum: undefined,
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      fieldname1: 0,
      fieldName2: 0,
      fieldName3: 0,
      fieldName4: 0,
      field0name5: 0,
      field0Name6: 0,
      fieldName7: 0,
      FieldName8: 0,
      fieldName9: 0,
      FieldName10: 0,
      FIELDNAME11: 0,
      FIELDName12: 0,
      fieldName13: 0,
      FieldName14: 0,
      fieldName15: 0,
      fieldName16: 0,
      fieldName17: 0,
      FieldName18: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypesProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypesProto2.NestedMessage._writeMessage,
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessageProto2._writeMessage,
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesProto2.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypesProto2.NestedEnum._toInt(msg.optionalNestedEnum),
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumProto2._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnumProto2._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.recursiveMessage) {
      writer.writeMessage(
        27,
        msg.recursiveMessage,
        TestAllTypesProto2._writeMessage,
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypesProto2.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessageProto2._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypesProto2.NestedEnum._toInt),
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumProto2._toInt),
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(75, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        76,
        msg.packedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(77, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        78,
        msg.packedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(79, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        80,
        msg.packedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(81, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        82,
        msg.packedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(83, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        84,
        msg.packedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(85, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(86, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(87, msg.packedBool);
    }
    if (msg.packedNestedEnum?.length) {
      writer.writePackedEnum(
        88,
        msg.packedNestedEnum.map(TestAllTypesProto2.NestedEnum._toInt),
      );
    }
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(89, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        90,
        msg.unpackedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(91, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        92,
        msg.unpackedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(93, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        94,
        msg.unpackedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(95, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        96,
        msg.unpackedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(97, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        98,
        msg.unpackedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(99, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(100, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(101, msg.unpackedBool);
    }
    if (msg.unpackedNestedEnum?.length) {
      writer.writePackedEnum(
        102,
        msg.unpackedNestedEnum.map(TestAllTypesProto2.NestedEnum._toInt),
      );
    }
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        56,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapInt32Int32._writeMessage,
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        57,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapInt64Int64._writeMessage,
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        58,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapUint32Uint32._writeMessage,
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        59,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapUint64Uint64._writeMessage,
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        60,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapSint32Sint32._writeMessage,
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        61,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapSint64Sint64._writeMessage,
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        62,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapFixed32Fixed32._writeMessage,
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        63,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapFixed64Fixed64._writeMessage,
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        64,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapSfixed32Sfixed32._writeMessage,
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        65,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapSfixed64Sfixed64._writeMessage,
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        66,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapInt32Float._writeMessage,
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        67,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapInt32Double._writeMessage,
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        68,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapBoolBool._writeMessage,
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        69,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringString._writeMessage,
      );
    }
    if (msg.mapStringBytes) {
      writer.writeRepeatedMessage(
        70,
        Object.entries(msg.mapStringBytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringBytes._writeMessage,
      );
    }
    if (msg.mapStringNestedMessage) {
      writer.writeRepeatedMessage(
        71,
        Object.entries(msg.mapStringNestedMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringNestedMessage._writeMessage,
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        72,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringForeignMessage._writeMessage,
      );
    }
    if (msg.mapStringNestedEnum) {
      writer.writeRepeatedMessage(
        73,
        Object.entries(msg.mapStringNestedEnum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringNestedEnum._writeMessage,
      );
    }
    if (msg.mapStringForeignEnum) {
      writer.writeRepeatedMessage(
        74,
        Object.entries(msg.mapStringForeignEnum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestAllTypesProto2.MapStringForeignEnum._writeMessage,
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypesProto2.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    if (msg.oneofBool != undefined) {
      writer.writeBool(115, msg.oneofBool);
    }
    if (msg.oneofUint64 != undefined) {
      writer.writeUint64String(116, msg.oneofUint64.toString() as any);
    }
    if (msg.oneofFloat != undefined) {
      writer.writeFloat(117, msg.oneofFloat);
    }
    if (msg.oneofDouble != undefined) {
      writer.writeDouble(118, msg.oneofDouble);
    }
    if (msg.oneofEnum != undefined) {
      writer.writeEnum(
        119,
        TestAllTypesProto2.NestedEnum._toInt(msg.oneofEnum),
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(241, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(242, msg.defaultInt64.toString() as any);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(243, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(244, msg.defaultUint64.toString() as any);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(245, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(246, msg.defaultSint64.toString() as any);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(247, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(248, msg.defaultFixed64.toString() as any);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(249, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(250, msg.defaultSfixed64.toString() as any);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(251, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(252, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(253, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(254, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(255, msg.defaultBytes);
    }
    if (msg.fieldname1) {
      writer.writeInt32(401, msg.fieldname1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(402, msg.fieldName2);
    }
    if (msg.fieldName3) {
      writer.writeInt32(403, msg.fieldName3);
    }
    if (msg.fieldName4) {
      writer.writeInt32(404, msg.fieldName4);
    }
    if (msg.field0name5) {
      writer.writeInt32(405, msg.field0name5);
    }
    if (msg.field0Name6) {
      writer.writeInt32(406, msg.field0Name6);
    }
    if (msg.fieldName7) {
      writer.writeInt32(407, msg.fieldName7);
    }
    if (msg.FieldName8) {
      writer.writeInt32(408, msg.FieldName8);
    }
    if (msg.fieldName9) {
      writer.writeInt32(409, msg.fieldName9);
    }
    if (msg.FieldName10) {
      writer.writeInt32(410, msg.FieldName10);
    }
    if (msg.FIELDNAME11) {
      writer.writeInt32(411, msg.FIELDNAME11);
    }
    if (msg.FIELDName12) {
      writer.writeInt32(412, msg.FIELDName12);
    }
    if (msg.fieldName13) {
      writer.writeInt32(413, msg.fieldName13);
    }
    if (msg.FieldName14) {
      writer.writeInt32(414, msg.FieldName14);
    }
    if (msg.fieldName15) {
      writer.writeInt32(415, msg.fieldName15);
    }
    if (msg.fieldName16) {
      writer.writeInt32(416, msg.fieldName16);
    }
    if (msg.fieldName17) {
      writer.writeInt32(417, msg.fieldName17);
    }
    if (msg.FieldName18) {
      writer.writeInt32(418, msg.FieldName18);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypesProto2,
    reader: BinaryReader,
  ): TestAllTypesProto2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypesProto2.NestedMessage._readMessage,
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessageProto2._readMessage,
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypesProto2.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumProto2._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 27: {
          msg.recursiveMessage = TestAllTypesProto2.initialize();
          reader.readMessage(
            msg.recursiveMessage,
            TestAllTypesProto2._readMessage,
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypesProto2.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypesProto2.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessageProto2.initialize();
          reader.readMessage(m, ForeignMessageProto2._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader
                .readPackedEnum()
                .map(TestAllTypesProto2.NestedEnum._fromInt),
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypesProto2.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnumProto2._fromInt),
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnumProto2._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 75: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 76: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 77: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 78: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 79: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 80: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 81: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 82: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 83: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 84: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 85: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 86: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 87: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 88: {
          if (reader.isDelimited()) {
            msg.packedNestedEnum.push(
              ...reader
                .readPackedEnum()
                .map(TestAllTypesProto2.NestedEnum._fromInt),
            );
          } else {
            msg.packedNestedEnum.push(
              TestAllTypesProto2.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 89: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedNestedEnum.push(
              ...reader
                .readPackedEnum()
                .map(TestAllTypesProto2.NestedEnum._fromInt),
            );
          } else {
            msg.unpackedNestedEnum.push(
              TestAllTypesProto2.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 56: {
          const map = {} as TestAllTypesProto2.MapInt32Int32;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapInt32Int32._readMessage,
          );
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 57: {
          const map = {} as TestAllTypesProto2.MapInt64Int64;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapInt64Int64._readMessage,
          );
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 58: {
          const map = {} as TestAllTypesProto2.MapUint32Uint32;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapUint32Uint32._readMessage,
          );
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 59: {
          const map = {} as TestAllTypesProto2.MapUint64Uint64;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapUint64Uint64._readMessage,
          );
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 60: {
          const map = {} as TestAllTypesProto2.MapSint32Sint32;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapSint32Sint32._readMessage,
          );
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 61: {
          const map = {} as TestAllTypesProto2.MapSint64Sint64;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapSint64Sint64._readMessage,
          );
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 62: {
          const map = {} as TestAllTypesProto2.MapFixed32Fixed32;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapFixed32Fixed32._readMessage,
          );
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 63: {
          const map = {} as TestAllTypesProto2.MapFixed64Fixed64;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapFixed64Fixed64._readMessage,
          );
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 64: {
          const map = {} as TestAllTypesProto2.MapSfixed32Sfixed32;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapSfixed32Sfixed32._readMessage,
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 65: {
          const map = {} as TestAllTypesProto2.MapSfixed64Sfixed64;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapSfixed64Sfixed64._readMessage,
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 66: {
          const map = {} as TestAllTypesProto2.MapInt32Float;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapInt32Float._readMessage,
          );
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 67: {
          const map = {} as TestAllTypesProto2.MapInt32Double;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapInt32Double._readMessage,
          );
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 68: {
          const map = {} as TestAllTypesProto2.MapBoolBool;
          reader.readMessage(map, TestAllTypesProto2.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 69: {
          const map = {} as TestAllTypesProto2.MapStringString;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringString._readMessage,
          );
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 70: {
          const map = {} as TestAllTypesProto2.MapStringBytes;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringBytes._readMessage,
          );
          msg.mapStringBytes[map.key.toString()] = map.value;
          break;
        }
        case 71: {
          const map = {} as TestAllTypesProto2.MapStringNestedMessage;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringNestedMessage._readMessage,
          );
          msg.mapStringNestedMessage[map.key.toString()] = map.value;
          break;
        }
        case 72: {
          const map = {} as TestAllTypesProto2.MapStringForeignMessage;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringForeignMessage._readMessage,
          );
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 73: {
          const map = {} as TestAllTypesProto2.MapStringNestedEnum;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringNestedEnum._readMessage,
          );
          msg.mapStringNestedEnum[map.key.toString()] = map.value;
          break;
        }
        case 74: {
          const map = {} as TestAllTypesProto2.MapStringForeignEnum;
          reader.readMessage(
            map,
            TestAllTypesProto2.MapStringForeignEnum._readMessage,
          );
          msg.mapStringForeignEnum[map.key.toString()] = map.value;
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage =
            TestAllTypesProto2.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypesProto2.NestedMessage._readMessage,
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        case 115: {
          msg.oneofBool = reader.readBool();
          break;
        }
        case 116: {
          msg.oneofUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 117: {
          msg.oneofFloat = reader.readFloat();
          break;
        }
        case 118: {
          msg.oneofDouble = reader.readDouble();
          break;
        }
        case 119: {
          msg.oneofEnum = TestAllTypesProto2.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 241: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 242: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 243: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 244: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 245: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 246: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 247: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 248: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 249: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 250: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 251: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 252: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 253: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 254: {
          msg.defaultString = reader.readString();
          break;
        }
        case 255: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 401: {
          msg.fieldname1 = reader.readInt32();
          break;
        }
        case 402: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 403: {
          msg.fieldName3 = reader.readInt32();
          break;
        }
        case 404: {
          msg.fieldName4 = reader.readInt32();
          break;
        }
        case 405: {
          msg.field0name5 = reader.readInt32();
          break;
        }
        case 406: {
          msg.field0Name6 = reader.readInt32();
          break;
        }
        case 407: {
          msg.fieldName7 = reader.readInt32();
          break;
        }
        case 408: {
          msg.FieldName8 = reader.readInt32();
          break;
        }
        case 409: {
          msg.fieldName9 = reader.readInt32();
          break;
        }
        case 410: {
          msg.FieldName10 = reader.readInt32();
          break;
        }
        case 411: {
          msg.FIELDNAME11 = reader.readInt32();
          break;
        }
        case 412: {
          msg.FIELDName12 = reader.readInt32();
          break;
        }
        case 413: {
          msg.fieldName13 = reader.readInt32();
          break;
        }
        case 414: {
          msg.FieldName14 = reader.readInt32();
          break;
        }
        case 415: {
          msg.fieldName15 = reader.readInt32();
          break;
        }
        case 416: {
          msg.fieldName16 = reader.readInt32();
          break;
        }
        case 417: {
          msg.fieldName17 = reader.readInt32();
          break;
        }
        case 418: {
          msg.FieldName18 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypesProto2.NestedEnum {
      switch (i) {
        case 0: {
          return "FOO";
        }
        case 1: {
          return "BAR";
        }
        case 2: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypesProto2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypesProto2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 0;
        }
        case "BAR": {
          return 1;
        }
        case "BAZ": {
          return 2;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypesProto2.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.NestedMessage>,
    ): Uint8Array {
      return TestAllTypesProto2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypesProto2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypesProto2.NestedMessage {
      return TestAllTypesProto2.NestedMessage._readMessage(
        TestAllTypesProto2.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypesProto2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.NestedMessage {
      return {
        a: 0,
        corecursive: undefined,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      if (msg.corecursive) {
        writer.writeMessage(
          2,
          msg.corecursive,
          TestAllTypesProto2._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.NestedMessage,
      reader: BinaryReader,
    ): TestAllTypesProto2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          case 2: {
            msg.corecursive = TestAllTypesProto2.initialize();
            reader.readMessage(
              msg.corecursive,
              TestAllTypesProto2._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Int32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Int32,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt64Int64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt64Int64,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapUint32Uint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapUint32Uint32,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapUint64Uint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapUint64Uint64,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSint32Sint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSint32Sint32,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSint64Sint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSint64Sint64,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapFixed32Fixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapFixed32Fixed32,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapFixed64Fixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapFixed64Fixed64,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSfixed32Sfixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSfixed32Sfixed32,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSfixed64Sfixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSfixed64Sfixed64,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Float>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Float,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Double>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Double,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapBoolBool>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapBoolBool,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringString>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringString,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringBytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringBytes>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringBytes,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringBytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringNestedMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringNestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestAllTypesProto2.NestedMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringNestedMessage,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringNestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestAllTypesProto2.NestedMessage.initialize();
            reader.readMessage(
              msg.value,
              TestAllTypesProto2.NestedMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringForeignMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessageProto2._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringForeignMessage,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = ForeignMessageProto2.initialize();
            reader.readMessage(msg.value, ForeignMessageProto2._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringNestedEnum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringNestedEnum>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value && TestAllTypesProto2.NestedEnum._toInt(msg.value)) {
        writer.writeEnum(2, TestAllTypesProto2.NestedEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringNestedEnum,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringNestedEnum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestAllTypesProto2.NestedEnum._fromInt(
              reader.readEnum(),
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignEnum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringForeignEnum>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value && ForeignEnumProto2._toInt(msg.value)) {
        writer.writeEnum(2, ForeignEnumProto2._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringForeignEnum,
      reader: BinaryReader,
    ): TestAllTypesProto2.MapStringForeignEnum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = ForeignEnumProto2._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Data: {
    /**
     * Serializes TestAllTypesProto2.Data to protobuf.
     */
    encode: function (msg: PartialDeep<TestAllTypesProto2.Data>): Uint8Array {
      return TestAllTypesProto2.Data._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypesProto2.Data from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypesProto2.Data {
      return TestAllTypesProto2.Data._readMessage(
        TestAllTypesProto2.Data.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypesProto2.Data with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.Data {
      return {
        groupInt32: 0,
        groupUint32: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.Data>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.groupInt32) {
        writer.writeInt32(202, msg.groupInt32);
      }
      if (msg.groupUint32) {
        writer.writeUint32(203, msg.groupUint32);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.Data,
      reader: BinaryReader,
    ): TestAllTypesProto2.Data {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 202: {
            msg.groupInt32 = reader.readInt32();
            break;
          }
          case 203: {
            msg.groupUint32 = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MessageSetCorrect: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrect to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<TestAllTypesProto2.MessageSetCorrect>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrect from protobuf.
     */
    decode: function (
      _bytes?: ByteSource,
    ): TestAllTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrect with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestAllTypesProto2.MessageSetCorrect>,
      writer: BinaryWriter,
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: TestAllTypesProto2.MessageSetCorrect,
      _reader: BinaryReader,
    ): TestAllTypesProto2.MessageSetCorrect {
      return _msg;
    },
  },

  MessageSetCorrectExtension1: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrectExtension1 to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension1>,
    ): Uint8Array {
      return TestAllTypesProto2.MessageSetCorrectExtension1._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrectExtension1 from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestAllTypesProto2.MessageSetCorrectExtension1 {
      return TestAllTypesProto2.MessageSetCorrectExtension1._readMessage(
        TestAllTypesProto2.MessageSetCorrectExtension1.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrectExtension1 with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrectExtension1 {
      return {
        str: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension1>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.str) {
        writer.writeString(25, msg.str);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MessageSetCorrectExtension1,
      reader: BinaryReader,
    ): TestAllTypesProto2.MessageSetCorrectExtension1 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 25: {
            msg.str = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MessageSetCorrectExtension2: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrectExtension2 to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension2>,
    ): Uint8Array {
      return TestAllTypesProto2.MessageSetCorrectExtension2._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrectExtension2 from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestAllTypesProto2.MessageSetCorrectExtension2 {
      return TestAllTypesProto2.MessageSetCorrectExtension2._readMessage(
        TestAllTypesProto2.MessageSetCorrectExtension2.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrectExtension2 with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrectExtension2 {
      return {
        i: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension2>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.i) {
        writer.writeInt32(9, msg.i);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MessageSetCorrectExtension2,
      reader: BinaryReader,
    ): TestAllTypesProto2.MessageSetCorrectExtension2 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.i = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const ForeignMessageProto2 = {
  /**
   * Serializes ForeignMessageProto2 to protobuf.
   */
  encode: function (msg: PartialDeep<ForeignMessageProto2>): Uint8Array {
    return ForeignMessageProto2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessageProto2 from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessageProto2 {
    return ForeignMessageProto2._readMessage(
      ForeignMessageProto2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ForeignMessageProto2 with all fields set to their default value.
   */
  initialize: function (): ForeignMessageProto2 {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessageProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessageProto2,
    reader: BinaryReader,
  ): ForeignMessageProto2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UnknownToTestAllTypes = {
  /**
   * Serializes UnknownToTestAllTypes to protobuf.
   */
  encode: function (msg: PartialDeep<UnknownToTestAllTypes>): Uint8Array {
    return UnknownToTestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UnknownToTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): UnknownToTestAllTypes {
    return UnknownToTestAllTypes._readMessage(
      UnknownToTestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes UnknownToTestAllTypes with all fields set to their default value.
   */
  initialize: function (): UnknownToTestAllTypes {
    return {
      optionalInt32: 0,
      optionalString: "",
      nestedMessage: ForeignMessageProto2.initialize(),
      optionalBool: false,
      repeatedInt32: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UnknownToTestAllTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1001, msg.optionalInt32);
    }
    if (msg.optionalString) {
      writer.writeString(1002, msg.optionalString);
    }
    if (msg.nestedMessage) {
      writer.writeMessage(
        1003,
        msg.nestedMessage,
        ForeignMessageProto2._writeMessage,
      );
    }
    if (msg.optionalBool) {
      writer.writeBool(1006, msg.optionalBool);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1011, msg.repeatedInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UnknownToTestAllTypes,
    reader: BinaryReader,
  ): UnknownToTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1001: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 1002: {
          msg.optionalString = reader.readString();
          break;
        }
        case 1003: {
          reader.readMessage(
            msg.nestedMessage,
            ForeignMessageProto2._readMessage,
          );
          break;
        }
        case 1006: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 1011: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes UnknownToTestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<UnknownToTestAllTypes.OptionalGroup>,
    ): Uint8Array {
      return UnknownToTestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes UnknownToTestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): UnknownToTestAllTypes.OptionalGroup {
      return UnknownToTestAllTypes.OptionalGroup._readMessage(
        UnknownToTestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes UnknownToTestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): UnknownToTestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UnknownToTestAllTypes.OptionalGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UnknownToTestAllTypes.OptionalGroup,
      reader: BinaryReader,
    ): UnknownToTestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NullHypothesisProto2 = {
  /**
   * Serializes NullHypothesisProto2 to protobuf.
   */
  encode: function (_msg?: PartialDeep<NullHypothesisProto2>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes NullHypothesisProto2 from protobuf.
   */
  decode: function (_bytes?: ByteSource): NullHypothesisProto2 {
    return {};
  },

  /**
   * Initializes NullHypothesisProto2 with all fields set to their default value.
   */
  initialize: function (): NullHypothesisProto2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<NullHypothesisProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: NullHypothesisProto2,
    _reader: BinaryReader,
  ): NullHypothesisProto2 {
    return _msg;
  },
};

export const EnumOnlyProto2 = {
  /**
   * Serializes EnumOnlyProto2 to protobuf.
   */
  encode: function (_msg?: PartialDeep<EnumOnlyProto2>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes EnumOnlyProto2 from protobuf.
   */
  decode: function (_bytes?: ByteSource): EnumOnlyProto2 {
    return {};
  },

  /**
   * Initializes EnumOnlyProto2 with all fields set to their default value.
   */
  initialize: function (): EnumOnlyProto2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EnumOnlyProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: EnumOnlyProto2,
    _reader: BinaryReader,
  ): EnumOnlyProto2 {
    return _msg;
  },

  Bool: {
    kFalse: "kFalse",
    kTrue: "kTrue",
    /**
     * @private
     */
    _fromInt: function (i: number): EnumOnlyProto2.Bool {
      switch (i) {
        case 0: {
          return "kFalse";
        }
        case 1: {
          return "kTrue";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as EnumOnlyProto2.Bool;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: EnumOnlyProto2.Bool): number {
      switch (i) {
        case "kFalse": {
          return 0;
        }
        case "kTrue": {
          return 1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const OneStringProto2 = {
  /**
   * Serializes OneStringProto2 to protobuf.
   */
  encode: function (msg: PartialDeep<OneStringProto2>): Uint8Array {
    return OneStringProto2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes OneStringProto2 from protobuf.
   */
  decode: function (bytes: ByteSource): OneStringProto2 {
    return OneStringProto2._readMessage(
      OneStringProto2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OneStringProto2 with all fields set to their default value.
   */
  initialize: function (): OneStringProto2 {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneStringProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneStringProto2,
    reader: BinaryReader,
  ): OneStringProto2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ProtoWithKeywords = {
  /**
   * Serializes ProtoWithKeywords to protobuf.
   */
  encode: function (msg: PartialDeep<ProtoWithKeywords>): Uint8Array {
    return ProtoWithKeywords._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ProtoWithKeywords from protobuf.
   */
  decode: function (bytes: ByteSource): ProtoWithKeywords {
    return ProtoWithKeywords._readMessage(
      ProtoWithKeywords.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ProtoWithKeywords with all fields set to their default value.
   */
  initialize: function (): ProtoWithKeywords {
    return {
      inline: 0,
      concept: "",
      requires: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ProtoWithKeywords>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.inline) {
      writer.writeInt32(1, msg.inline);
    }
    if (msg.concept) {
      writer.writeString(2, msg.concept);
    }
    if (msg.requires?.length) {
      writer.writeRepeatedString(3, msg.requires);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ProtoWithKeywords,
    reader: BinaryReader,
  ): ProtoWithKeywords {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inline = reader.readInt32();
          break;
        }
        case 2: {
          msg.concept = reader.readString();
          break;
        }
        case 3: {
          msg.requires.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestAllRequiredTypesProto2 = {
  /**
   * Serializes TestAllRequiredTypesProto2 to protobuf.
   */
  encode: function (msg: PartialDeep<TestAllRequiredTypesProto2>): Uint8Array {
    return TestAllRequiredTypesProto2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllRequiredTypesProto2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllRequiredTypesProto2 {
    return TestAllRequiredTypesProto2._readMessage(
      TestAllRequiredTypesProto2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestAllRequiredTypesProto2 with all fields set to their default value.
   */
  initialize: function (): TestAllRequiredTypesProto2 {
    return {
      requiredInt32: 0,
      requiredInt64: 0n,
      requiredUint32: 0,
      requiredUint64: 0n,
      requiredSint32: 0,
      requiredSint64: 0n,
      requiredFixed32: 0,
      requiredFixed64: 0n,
      requiredSfixed32: 0,
      requiredSfixed64: 0n,
      requiredFloat: 0,
      requiredDouble: 0,
      requiredBool: false,
      requiredString: "",
      requiredBytes: new Uint8Array(),
      requiredNestedMessage:
        TestAllRequiredTypesProto2.NestedMessage.initialize(),
      requiredForeignMessage: ForeignMessageProto2.initialize(),
      requiredNestedEnum: TestAllRequiredTypesProto2.NestedEnum._fromInt(0),
      requiredForeignEnum: ForeignEnumProto2._fromInt(0),
      requiredStringPiece: "",
      requiredCord: "",
      recursiveMessage: undefined,
      optionalRecursiveMessage: undefined,
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllRequiredTypesProto2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.requiredInt32) {
      writer.writeInt32(1, msg.requiredInt32);
    }
    if (msg.requiredInt64) {
      writer.writeInt64String(2, msg.requiredInt64.toString() as any);
    }
    if (msg.requiredUint32) {
      writer.writeUint32(3, msg.requiredUint32);
    }
    if (msg.requiredUint64) {
      writer.writeUint64String(4, msg.requiredUint64.toString() as any);
    }
    if (msg.requiredSint32) {
      writer.writeSint32(5, msg.requiredSint32);
    }
    if (msg.requiredSint64) {
      writer.writeSint64String(6, msg.requiredSint64.toString() as any);
    }
    if (msg.requiredFixed32) {
      writer.writeFixed32(7, msg.requiredFixed32);
    }
    if (msg.requiredFixed64) {
      writer.writeFixed64String(8, msg.requiredFixed64.toString() as any);
    }
    if (msg.requiredSfixed32) {
      writer.writeSfixed32(9, msg.requiredSfixed32);
    }
    if (msg.requiredSfixed64) {
      writer.writeSfixed64String(10, msg.requiredSfixed64.toString() as any);
    }
    if (msg.requiredFloat) {
      writer.writeFloat(11, msg.requiredFloat);
    }
    if (msg.requiredDouble) {
      writer.writeDouble(12, msg.requiredDouble);
    }
    if (msg.requiredBool) {
      writer.writeBool(13, msg.requiredBool);
    }
    if (msg.requiredString) {
      writer.writeString(14, msg.requiredString);
    }
    if (msg.requiredBytes?.length) {
      writer.writeBytes(15, msg.requiredBytes);
    }
    if (msg.requiredNestedMessage) {
      writer.writeMessage(
        18,
        msg.requiredNestedMessage,
        TestAllRequiredTypesProto2.NestedMessage._writeMessage,
      );
    }
    if (msg.requiredForeignMessage) {
      writer.writeMessage(
        19,
        msg.requiredForeignMessage,
        ForeignMessageProto2._writeMessage,
      );
    }
    if (
      msg.requiredNestedEnum &&
      TestAllRequiredTypesProto2.NestedEnum._toInt(msg.requiredNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllRequiredTypesProto2.NestedEnum._toInt(msg.requiredNestedEnum),
      );
    }
    if (
      msg.requiredForeignEnum &&
      ForeignEnumProto2._toInt(msg.requiredForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnumProto2._toInt(msg.requiredForeignEnum));
    }
    if (msg.requiredStringPiece) {
      writer.writeString(24, msg.requiredStringPiece);
    }
    if (msg.requiredCord) {
      writer.writeString(25, msg.requiredCord);
    }
    if (msg.recursiveMessage) {
      writer.writeMessage(
        27,
        msg.recursiveMessage,
        TestAllRequiredTypesProto2._writeMessage,
      );
    }
    if (msg.optionalRecursiveMessage) {
      writer.writeMessage(
        28,
        msg.optionalRecursiveMessage,
        TestAllRequiredTypesProto2._writeMessage,
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(241, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(242, msg.defaultInt64.toString() as any);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(243, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(244, msg.defaultUint64.toString() as any);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(245, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(246, msg.defaultSint64.toString() as any);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(247, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(248, msg.defaultFixed64.toString() as any);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(249, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(250, msg.defaultSfixed64.toString() as any);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(251, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(252, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(253, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(254, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(255, msg.defaultBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllRequiredTypesProto2,
    reader: BinaryReader,
  ): TestAllRequiredTypesProto2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.requiredInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.requiredInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.requiredUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.requiredUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.requiredSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.requiredSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.requiredFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.requiredFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.requiredSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.requiredSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.requiredFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.requiredDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.requiredBool = reader.readBool();
          break;
        }
        case 14: {
          msg.requiredString = reader.readString();
          break;
        }
        case 15: {
          msg.requiredBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.requiredNestedMessage,
            TestAllRequiredTypesProto2.NestedMessage._readMessage,
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.requiredForeignMessage,
            ForeignMessageProto2._readMessage,
          );
          break;
        }
        case 21: {
          msg.requiredNestedEnum =
            TestAllRequiredTypesProto2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 22: {
          msg.requiredForeignEnum = ForeignEnumProto2._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 24: {
          msg.requiredStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.requiredCord = reader.readString();
          break;
        }
        case 27: {
          msg.recursiveMessage = TestAllRequiredTypesProto2.initialize();
          reader.readMessage(
            msg.recursiveMessage,
            TestAllRequiredTypesProto2._readMessage,
          );
          break;
        }
        case 28: {
          msg.optionalRecursiveMessage =
            TestAllRequiredTypesProto2.initialize();
          reader.readMessage(
            msg.optionalRecursiveMessage,
            TestAllRequiredTypesProto2._readMessage,
          );
          break;
        }
        case 241: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 242: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 243: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 244: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 245: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 246: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 247: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 248: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 249: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 250: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 251: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 252: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 253: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 254: {
          msg.defaultString = reader.readString();
          break;
        }
        case 255: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllRequiredTypesProto2.NestedEnum {
      switch (i) {
        case 0: {
          return "FOO";
        }
        case 1: {
          return "BAR";
        }
        case 2: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllRequiredTypesProto2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllRequiredTypesProto2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 0;
        }
        case "BAR": {
          return 1;
        }
        case "BAZ": {
          return 2;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllRequiredTypesProto2.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.NestedMessage>,
    ): Uint8Array {
      return TestAllRequiredTypesProto2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestAllRequiredTypesProto2.NestedMessage {
      return TestAllRequiredTypesProto2.NestedMessage._readMessage(
        TestAllRequiredTypesProto2.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.NestedMessage {
      return {
        a: 0,
        corecursive: undefined,
        optionalCorecursive: undefined,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      if (msg.corecursive) {
        writer.writeMessage(
          2,
          msg.corecursive,
          TestAllRequiredTypesProto2._writeMessage,
        );
      }
      if (msg.optionalCorecursive) {
        writer.writeMessage(
          3,
          msg.optionalCorecursive,
          TestAllRequiredTypesProto2._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.NestedMessage,
      reader: BinaryReader,
    ): TestAllRequiredTypesProto2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          case 2: {
            msg.corecursive = TestAllRequiredTypesProto2.initialize();
            reader.readMessage(
              msg.corecursive,
              TestAllRequiredTypesProto2._readMessage,
            );
            break;
          }
          case 3: {
            msg.optionalCorecursive = TestAllRequiredTypesProto2.initialize();
            reader.readMessage(
              msg.optionalCorecursive,
              TestAllRequiredTypesProto2._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Data: {
    /**
     * Serializes TestAllRequiredTypesProto2.Data to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.Data>,
    ): Uint8Array {
      return TestAllRequiredTypesProto2.Data._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.Data from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllRequiredTypesProto2.Data {
      return TestAllRequiredTypesProto2.Data._readMessage(
        TestAllRequiredTypesProto2.Data.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.Data with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.Data {
      return {
        groupInt32: 0,
        groupUint32: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.Data>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.groupInt32) {
        writer.writeInt32(202, msg.groupInt32);
      }
      if (msg.groupUint32) {
        writer.writeUint32(203, msg.groupUint32);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.Data,
      reader: BinaryReader,
    ): TestAllRequiredTypesProto2.Data {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 202: {
            msg.groupInt32 = reader.readInt32();
            break;
          }
          case 203: {
            msg.groupUint32 = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MessageSetCorrect: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrect to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrect>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrect from protobuf.
     */
    decode: function (
      _bytes?: ByteSource,
    ): TestAllRequiredTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrect with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrect>,
      writer: BinaryWriter,
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: TestAllRequiredTypesProto2.MessageSetCorrect,
      _reader: BinaryReader,
    ): TestAllRequiredTypesProto2.MessageSetCorrect {
      return _msg;
    },
  },

  MessageSetCorrectExtension1: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension1>,
    ): Uint8Array {
      return TestAllRequiredTypesProto2.MessageSetCorrectExtension1._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
      return TestAllRequiredTypesProto2.MessageSetCorrectExtension1._readMessage(
        TestAllRequiredTypesProto2.MessageSetCorrectExtension1.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 with all fields set to their default value.
     */
    initialize:
      function (): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
        return {
          str: "",
        };
      },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension1>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.str) {
        writer.writeString(25, msg.str);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.MessageSetCorrectExtension1,
      reader: BinaryReader,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 25: {
            msg.str = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MessageSetCorrectExtension2: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension2>,
    ): Uint8Array {
      return TestAllRequiredTypesProto2.MessageSetCorrectExtension2._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
      return TestAllRequiredTypesProto2.MessageSetCorrectExtension2._readMessage(
        TestAllRequiredTypesProto2.MessageSetCorrectExtension2.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 with all fields set to their default value.
     */
    initialize:
      function (): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
        return {
          i: 0,
        };
      },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension2>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.i) {
        writer.writeInt32(9, msg.i);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.MessageSetCorrectExtension2,
      reader: BinaryReader,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.i = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumProto2JSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnumProto2 {
    switch (i) {
      case 0: {
        return "FOREIGN_FOO";
      }
      case 1: {
        return "FOREIGN_BAR";
      }
      case 2: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnumProto2;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnumProto2): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 0;
      }
      case "FOREIGN_BAR": {
        return 1;
      }
      case "FOREIGN_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesProto2JSON = {
  /**
   * Serializes TestAllTypesProto2 to JSON.
   */
  encode: function (msg: PartialDeep<TestAllTypesProto2>): string {
    return JSON.stringify(TestAllTypesProto2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypesProto2 from JSON.
   */
  decode: function (json: string): TestAllTypesProto2 {
    return TestAllTypesProto2JSON._readMessage(
      TestAllTypesProto2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestAllTypesProto2 with all fields set to their default value.
   */
  initialize: function (): TestAllTypesProto2 {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesProto2JSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageProto2JSON.initialize(),
      optionalNestedEnum: TestAllTypesProto2.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnumProto2._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      recursiveMessage: undefined,
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedNestedEnum: [],
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedNestedEnum: [],
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapStringBytes: {},
      mapStringNestedMessage: {},
      mapStringForeignMessage: {},
      mapStringNestedEnum: {},
      mapStringForeignEnum: {},
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
      oneofBool: undefined,
      oneofUint64: undefined,
      oneofFloat: undefined,
      oneofDouble: undefined,
      oneofEnum: undefined,
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      fieldname1: 0,
      fieldName2: 0,
      fieldName3: 0,
      fieldName4: 0,
      field0name5: 0,
      field0Name6: 0,
      fieldName7: 0,
      FieldName8: 0,
      fieldName9: 0,
      FieldName10: 0,
      FIELDNAME11: 0,
      FIELDName12: 0,
      fieldName13: 0,
      FieldName14: 0,
      fieldName15: 0,
      fieldName16: 0,
      fieldName17: 0,
      FieldName18: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypesProto2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesProto2JSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage,
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageProto2JSON._writeMessage(
        msg.optionalForeignMessage,
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesProto2JSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumProto2JSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.recursiveMessage) {
      const _recursiveMessage_ = TestAllTypesProto2JSON._writeMessage(
        msg.recursiveMessage,
      );
      if (Object.keys(_recursiveMessage_).length > 0) {
        json["recursiveMessage"] = _recursiveMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesProto2JSON.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageProto2JSON._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedNestedEnum?.length) {
      json["packedNestedEnum"] = msg.packedNestedEnum;
    }
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedNestedEnum?.length) {
      json["unpackedNestedEnum"] = msg.unpackedNestedEnum;
    }
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapStringBytes) {
      const _mapStringBytes_ = Object.fromEntries(
        Object.entries(msg.mapStringBytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringBytes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringBytes_).length > 0) {
        json["mapStringBytes"] = _mapStringBytes_;
      }
    }
    if (msg.mapStringNestedMessage) {
      const _mapStringNestedMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringNestedMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringNestedMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringNestedMessage_).length > 0) {
        json["mapStringNestedMessage"] = _mapStringNestedMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapStringNestedEnum) {
      const _mapStringNestedEnum_ = Object.fromEntries(
        Object.entries(msg.mapStringNestedEnum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringNestedEnum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringNestedEnum_).length > 0) {
        json["mapStringNestedEnum"] = _mapStringNestedEnum_;
      }
    }
    if (msg.mapStringForeignEnum) {
      const _mapStringForeignEnum_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignEnum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringForeignEnum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringForeignEnum_).length > 0) {
        json["mapStringForeignEnum"] = _mapStringForeignEnum_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ =
        TestAllTypesProto2JSON.NestedMessage._writeMessage(
          msg.oneofNestedMessage,
        );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    if (msg.oneofBool != undefined) {
      json["oneofBool"] = msg.oneofBool;
    }
    if (msg.oneofUint64 != undefined) {
      json["oneofUint64"] = msg.oneofUint64.toString();
    }
    if (msg.oneofFloat != undefined) {
      json["oneofFloat"] = msg.oneofFloat;
    }
    if (msg.oneofDouble != undefined) {
      json["oneofDouble"] = msg.oneofDouble;
    }
    if (msg.oneofEnum != undefined) {
      json["oneofEnum"] = msg.oneofEnum;
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (msg.fieldname1) {
      json["fieldname1"] = msg.fieldname1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.fieldName3) {
      json["FieldName3"] = msg.fieldName3;
    }
    if (msg.fieldName4) {
      json["fieldName4"] = msg.fieldName4;
    }
    if (msg.field0name5) {
      json["field0name5"] = msg.field0name5;
    }
    if (msg.field0Name6) {
      json["field0Name6"] = msg.field0Name6;
    }
    if (msg.fieldName7) {
      json["fieldName7"] = msg.fieldName7;
    }
    if (msg.FieldName8) {
      json["FieldName8"] = msg.FieldName8;
    }
    if (msg.fieldName9) {
      json["fieldName9"] = msg.fieldName9;
    }
    if (msg.FieldName10) {
      json["FieldName10"] = msg.FieldName10;
    }
    if (msg.FIELDNAME11) {
      json["FIELDNAME11"] = msg.FIELDNAME11;
    }
    if (msg.FIELDName12) {
      json["FIELDName12"] = msg.FIELDName12;
    }
    if (msg.fieldName13) {
      json["FieldName13"] = msg.fieldName13;
    }
    if (msg.FieldName14) {
      json["FieldName14"] = msg.FieldName14;
    }
    if (msg.fieldName15) {
      json["fieldName15"] = msg.fieldName15;
    }
    if (msg.fieldName16) {
      json["fieldName16"] = msg.fieldName16;
    }
    if (msg.fieldName17) {
      json["fieldName17"] = msg.fieldName17;
    }
    if (msg.FieldName18) {
      json["FieldName18"] = msg.FieldName18;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypesProto2,
    json: any,
  ): TestAllTypesProto2 {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestAllTypesProto2JSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      ForeignMessageProto2JSON._readMessage(
        msg.optionalForeignMessage,
        _optionalForeignMessage_,
      );
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _recursiveMessage_ =
      json["recursiveMessage"] ?? json["recursive_message"];
    if (_recursiveMessage_) {
      msg.recursiveMessage = TestAllTypesProto2JSON.initialize();
      TestAllTypesProto2JSON._readMessage(
        msg.recursiveMessage,
        _recursiveMessage_,
      );
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypesProto2JSON.NestedMessage.initialize();
        TestAllTypesProto2JSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessageProto2JSON.initialize();
        ForeignMessageProto2JSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedNestedEnum_ =
      json["packedNestedEnum"] ?? json["packed_nested_enum"];
    if (_packedNestedEnum_) {
      msg.packedNestedEnum = _packedNestedEnum_;
    }
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedNestedEnum_ =
      json["unpackedNestedEnum"] ?? json["unpacked_nested_enum"];
    if (_unpackedNestedEnum_) {
      msg.unpackedNestedEnum = _unpackedNestedEnum_;
    }
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringBytes_ = json["mapStringBytes"] ?? json["map_string_bytes"];
    if (_mapStringBytes_) {
      msg.mapStringBytes = Object.fromEntries(
        Object.entries(_mapStringBytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringBytes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringNestedMessage_ =
      json["mapStringNestedMessage"] ?? json["map_string_nested_message"];
    if (_mapStringNestedMessage_) {
      msg.mapStringNestedMessage = Object.fromEntries(
        Object.entries(_mapStringNestedMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringNestedMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringNestedEnum_ =
      json["mapStringNestedEnum"] ?? json["map_string_nested_enum"];
    if (_mapStringNestedEnum_) {
      msg.mapStringNestedEnum = Object.fromEntries(
        Object.entries(_mapStringNestedEnum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringNestedEnum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringForeignEnum_ =
      json["mapStringForeignEnum"] ?? json["map_string_foreign_enum"];
    if (_mapStringForeignEnum_) {
      msg.mapStringForeignEnum = Object.fromEntries(
        Object.entries(_mapStringForeignEnum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestAllTypesProto2JSON.MapStringForeignEnum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      msg.oneofNestedMessage =
        TestAllTypesProto2JSON.NestedMessage.initialize();
      TestAllTypesProto2JSON.NestedMessage._readMessage(
        msg.oneofNestedMessage,
        _oneofNestedMessage_,
      );
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    const _oneofBool_ = json["oneofBool"] ?? json["oneof_bool"];
    if (_oneofBool_) {
      msg.oneofBool = _oneofBool_;
    }
    const _oneofUint64_ = json["oneofUint64"] ?? json["oneof_uint64"];
    if (_oneofUint64_) {
      msg.oneofUint64 = BigInt(_oneofUint64_);
    }
    const _oneofFloat_ = json["oneofFloat"] ?? json["oneof_float"];
    if (_oneofFloat_) {
      msg.oneofFloat = _oneofFloat_;
    }
    const _oneofDouble_ = json["oneofDouble"] ?? json["oneof_double"];
    if (_oneofDouble_) {
      msg.oneofDouble = _oneofDouble_;
    }
    const _oneofEnum_ = json["oneofEnum"] ?? json["oneof_enum"];
    if (_oneofEnum_) {
      msg.oneofEnum = _oneofEnum_;
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _fieldname1_ = json["fieldname1"];
    if (_fieldname1_) {
      msg.fieldname1 = _fieldname1_;
    }
    const _fieldName2_ = json["fieldName2"] ?? json["field_name2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _fieldName3_ =
      json["FieldName3"] ?? json["fieldName3"] ?? json["_field_name3"];
    if (_fieldName3_) {
      msg.fieldName3 = _fieldName3_;
    }
    const _fieldName4_ = json["fieldName4"] ?? json["field__name4_"];
    if (_fieldName4_) {
      msg.fieldName4 = _fieldName4_;
    }
    const _field0name5_ = json["field0name5"];
    if (_field0name5_) {
      msg.field0name5 = _field0name5_;
    }
    const _field0Name6_ = json["field0Name6"] ?? json["field_0_name6"];
    if (_field0Name6_) {
      msg.field0Name6 = _field0Name6_;
    }
    const _fieldName7_ = json["fieldName7"];
    if (_fieldName7_) {
      msg.fieldName7 = _fieldName7_;
    }
    const _FieldName8_ = json["FieldName8"];
    if (_FieldName8_) {
      msg.FieldName8 = _FieldName8_;
    }
    const _fieldName9_ = json["fieldName9"] ?? json["field_Name9"];
    if (_fieldName9_) {
      msg.fieldName9 = _fieldName9_;
    }
    const _FieldName10_ = json["FieldName10"] ?? json["Field_Name10"];
    if (_FieldName10_) {
      msg.FieldName10 = _FieldName10_;
    }
    const _FIELDNAME11_ = json["FIELDNAME11"] ?? json["FIELD_NAME11"];
    if (_FIELDNAME11_) {
      msg.FIELDNAME11 = _FIELDNAME11_;
    }
    const _FIELDName12_ = json["FIELDName12"] ?? json["FIELD_name12"];
    if (_FIELDName12_) {
      msg.FIELDName12 = _FIELDName12_;
    }
    const _fieldName13_ =
      json["FieldName13"] ?? json["fieldName13"] ?? json["__field_name13"];
    if (_fieldName13_) {
      msg.fieldName13 = _fieldName13_;
    }
    const _FieldName14_ = json["FieldName14"] ?? json["__Field_name14"];
    if (_FieldName14_) {
      msg.FieldName14 = _FieldName14_;
    }
    const _fieldName15_ = json["fieldName15"] ?? json["field__name15"];
    if (_fieldName15_) {
      msg.fieldName15 = _fieldName15_;
    }
    const _fieldName16_ = json["fieldName16"] ?? json["field__Name16"];
    if (_fieldName16_) {
      msg.fieldName16 = _fieldName16_;
    }
    const _fieldName17_ = json["fieldName17"] ?? json["field_name17__"];
    if (_fieldName17_) {
      msg.fieldName17 = _fieldName17_;
    }
    const _FieldName18_ = json["FieldName18"] ?? json["Field_name18__"];
    if (_FieldName18_) {
      msg.FieldName18 = _FieldName18_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypesProto2.NestedEnum {
      switch (i) {
        case 0: {
          return "FOO";
        }
        case 1: {
          return "BAR";
        }
        case 2: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypesProto2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypesProto2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 0;
        }
        case "BAR": {
          return 1;
        }
        case "BAZ": {
          return 2;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypesProto2.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestAllTypesProto2JSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestAllTypesProto2.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypesProto2.NestedMessage {
      return TestAllTypesProto2JSON.NestedMessage._readMessage(
        TestAllTypesProto2JSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypesProto2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.NestedMessage {
      return {
        a: 0,
        corecursive: undefined,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.corecursive) {
        const _corecursive_ = TestAllTypesProto2JSON._writeMessage(
          msg.corecursive,
        );
        if (Object.keys(_corecursive_).length > 0) {
          json["corecursive"] = _corecursive_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.NestedMessage,
      json: any,
    ): TestAllTypesProto2.NestedMessage {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _corecursive_ = json["corecursive"];
      if (_corecursive_) {
        msg.corecursive = TestAllTypesProto2JSON.initialize();
        TestAllTypesProto2JSON._readMessage(msg.corecursive, _corecursive_);
      }
      return msg;
    },
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Int32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Int32,
      json: any,
    ): TestAllTypesProto2.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt64Int64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt64Int64,
      json: any,
    ): TestAllTypesProto2.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapUint32Uint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapUint32Uint32,
      json: any,
    ): TestAllTypesProto2.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapUint64Uint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapUint64Uint64,
      json: any,
    ): TestAllTypesProto2.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSint32Sint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSint32Sint32,
      json: any,
    ): TestAllTypesProto2.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSint64Sint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSint64Sint64,
      json: any,
    ): TestAllTypesProto2.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapFixed32Fixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapFixed32Fixed32,
      json: any,
    ): TestAllTypesProto2.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapFixed64Fixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapFixed64Fixed64,
      json: any,
    ): TestAllTypesProto2.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSfixed32Sfixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSfixed32Sfixed32,
      json: any,
    ): TestAllTypesProto2.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapSfixed64Sfixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapSfixed64Sfixed64,
      json: any,
    ): TestAllTypesProto2.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Float>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Float,
      json: any,
    ): TestAllTypesProto2.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapInt32Double>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapInt32Double,
      json: any,
    ): TestAllTypesProto2.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapBoolBool>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapBoolBool,
      json: any,
    ): TestAllTypesProto2.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringString>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringString,
      json: any,
    ): TestAllTypesProto2.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringBytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringBytes>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringBytes,
      json: any,
    ): TestAllTypesProto2.MapStringBytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapStringNestedMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringNestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestAllTypesProto2JSON.NestedMessage._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringNestedMessage,
      json: any,
    ): TestAllTypesProto2.MapStringNestedMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        TestAllTypesProto2JSON.NestedMessage._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringForeignMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = ForeignMessageProto2JSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringForeignMessage,
      json: any,
    ): TestAllTypesProto2.MapStringForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        ForeignMessageProto2JSON._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },

  MapStringNestedEnum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringNestedEnum>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && TestAllTypesProto2JSON.NestedEnum._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringNestedEnum,
      json: any,
    ): TestAllTypesProto2.MapStringNestedEnum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringForeignEnum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MapStringForeignEnum>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && ForeignEnumProto2JSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MapStringForeignEnum,
      json: any,
    ): TestAllTypesProto2.MapStringForeignEnum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Data: {
    /**
     * Serializes TestAllTypesProto2.Data to JSON.
     */
    encode: function (msg: PartialDeep<TestAllTypesProto2.Data>): string {
      return JSON.stringify(TestAllTypesProto2JSON.Data._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypesProto2.Data from JSON.
     */
    decode: function (json: string): TestAllTypesProto2.Data {
      return TestAllTypesProto2JSON.Data._readMessage(
        TestAllTypesProto2JSON.Data.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypesProto2.Data with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.Data {
      return {
        groupInt32: 0,
        groupUint32: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.Data>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupInt32) {
        json["groupInt32"] = msg.groupInt32;
      }
      if (msg.groupUint32) {
        json["groupUint32"] = msg.groupUint32;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.Data,
      json: any,
    ): TestAllTypesProto2.Data {
      const _groupInt32_ = json["groupInt32"] ?? json["group_int32"];
      if (_groupInt32_) {
        msg.groupInt32 = _groupInt32_;
      }
      const _groupUint32_ = json["groupUint32"] ?? json["group_uint32"];
      if (_groupUint32_) {
        msg.groupUint32 = _groupUint32_;
      }
      return msg;
    },
  },

  MessageSetCorrect: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrect to JSON.
     */
    encode: function (
      _msg?: PartialDeep<TestAllTypesProto2.MessageSetCorrect>,
    ): string {
      return "{}";
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrect from JSON.
     */
    decode: function (_json?: string): TestAllTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrect with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestAllTypesProto2.MessageSetCorrect>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MessageSetCorrect,
      _json: any,
    ): TestAllTypesProto2.MessageSetCorrect {
      return msg;
    },
  },

  MessageSetCorrectExtension1: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrectExtension1 to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension1>,
    ): string {
      return JSON.stringify(
        TestAllTypesProto2JSON.MessageSetCorrectExtension1._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrectExtension1 from JSON.
     */
    decode: function (
      json: string,
    ): TestAllTypesProto2.MessageSetCorrectExtension1 {
      return TestAllTypesProto2JSON.MessageSetCorrectExtension1._readMessage(
        TestAllTypesProto2JSON.MessageSetCorrectExtension1.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrectExtension1 with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrectExtension1 {
      return {
        str: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension1>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.str) {
        json["str"] = msg.str;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MessageSetCorrectExtension1,
      json: any,
    ): TestAllTypesProto2.MessageSetCorrectExtension1 {
      const _str_ = json["str"];
      if (_str_) {
        msg.str = _str_;
      }
      return msg;
    },
  },

  MessageSetCorrectExtension2: {
    /**
     * Serializes TestAllTypesProto2.MessageSetCorrectExtension2 to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension2>,
    ): string {
      return JSON.stringify(
        TestAllTypesProto2JSON.MessageSetCorrectExtension2._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestAllTypesProto2.MessageSetCorrectExtension2 from JSON.
     */
    decode: function (
      json: string,
    ): TestAllTypesProto2.MessageSetCorrectExtension2 {
      return TestAllTypesProto2JSON.MessageSetCorrectExtension2._readMessage(
        TestAllTypesProto2JSON.MessageSetCorrectExtension2.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypesProto2.MessageSetCorrectExtension2 with all fields set to their default value.
     */
    initialize: function (): TestAllTypesProto2.MessageSetCorrectExtension2 {
      return {
        i: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypesProto2.MessageSetCorrectExtension2>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.i) {
        json["i"] = msg.i;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypesProto2.MessageSetCorrectExtension2,
      json: any,
    ): TestAllTypesProto2.MessageSetCorrectExtension2 {
      const _i_ = json["i"];
      if (_i_) {
        msg.i = _i_;
      }
      return msg;
    },
  },
};

export const ForeignMessageProto2JSON = {
  /**
   * Serializes ForeignMessageProto2 to JSON.
   */
  encode: function (msg: PartialDeep<ForeignMessageProto2>): string {
    return JSON.stringify(ForeignMessageProto2JSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessageProto2 from JSON.
   */
  decode: function (json: string): ForeignMessageProto2 {
    return ForeignMessageProto2JSON._readMessage(
      ForeignMessageProto2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ForeignMessageProto2 with all fields set to their default value.
   */
  initialize: function (): ForeignMessageProto2 {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessageProto2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessageProto2,
    json: any,
  ): ForeignMessageProto2 {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const UnknownToTestAllTypesJSON = {
  /**
   * Serializes UnknownToTestAllTypes to JSON.
   */
  encode: function (msg: PartialDeep<UnknownToTestAllTypes>): string {
    return JSON.stringify(UnknownToTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes UnknownToTestAllTypes from JSON.
   */
  decode: function (json: string): UnknownToTestAllTypes {
    return UnknownToTestAllTypesJSON._readMessage(
      UnknownToTestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UnknownToTestAllTypes with all fields set to their default value.
   */
  initialize: function (): UnknownToTestAllTypes {
    return {
      optionalInt32: 0,
      optionalString: "",
      nestedMessage: ForeignMessageProto2JSON.initialize(),
      optionalBool: false,
      repeatedInt32: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UnknownToTestAllTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.nestedMessage) {
      const _nestedMessage_ = ForeignMessageProto2JSON._writeMessage(
        msg.nestedMessage,
      );
      if (Object.keys(_nestedMessage_).length > 0) {
        json["nestedMessage"] = _nestedMessage_;
      }
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UnknownToTestAllTypes,
    json: any,
  ): UnknownToTestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _nestedMessage_ = json["nestedMessage"] ?? json["nested_message"];
    if (_nestedMessage_) {
      ForeignMessageProto2JSON._readMessage(msg.nestedMessage, _nestedMessage_);
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes UnknownToTestAllTypes.OptionalGroup to JSON.
     */
    encode: function (
      msg: PartialDeep<UnknownToTestAllTypes.OptionalGroup>,
    ): string {
      return JSON.stringify(
        UnknownToTestAllTypesJSON.OptionalGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes UnknownToTestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json: string): UnknownToTestAllTypes.OptionalGroup {
      return UnknownToTestAllTypesJSON.OptionalGroup._readMessage(
        UnknownToTestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes UnknownToTestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): UnknownToTestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UnknownToTestAllTypes.OptionalGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UnknownToTestAllTypes.OptionalGroup,
      json: any,
    ): UnknownToTestAllTypes.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NullHypothesisProto2JSON = {
  /**
   * Serializes NullHypothesisProto2 to JSON.
   */
  encode: function (_msg?: PartialDeep<NullHypothesisProto2>): string {
    return "{}";
  },

  /**
   * Deserializes NullHypothesisProto2 from JSON.
   */
  decode: function (_json?: string): NullHypothesisProto2 {
    return {};
  },

  /**
   * Initializes NullHypothesisProto2 with all fields set to their default value.
   */
  initialize: function (): NullHypothesisProto2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<NullHypothesisProto2>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NullHypothesisProto2,
    _json: any,
  ): NullHypothesisProto2 {
    return msg;
  },
};

export const EnumOnlyProto2JSON = {
  /**
   * Serializes EnumOnlyProto2 to JSON.
   */
  encode: function (_msg?: PartialDeep<EnumOnlyProto2>): string {
    return "{}";
  },

  /**
   * Deserializes EnumOnlyProto2 from JSON.
   */
  decode: function (_json?: string): EnumOnlyProto2 {
    return {};
  },

  /**
   * Initializes EnumOnlyProto2 with all fields set to their default value.
   */
  initialize: function (): EnumOnlyProto2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EnumOnlyProto2>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: EnumOnlyProto2, _json: any): EnumOnlyProto2 {
    return msg;
  },

  Bool: {
    kFalse: "kFalse",
    kTrue: "kTrue",
    /**
     * @private
     */
    _fromInt: function (i: number): EnumOnlyProto2.Bool {
      switch (i) {
        case 0: {
          return "kFalse";
        }
        case 1: {
          return "kTrue";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as EnumOnlyProto2.Bool;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: EnumOnlyProto2.Bool): number {
      switch (i) {
        case "kFalse": {
          return 0;
        }
        case "kTrue": {
          return 1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const OneStringProto2JSON = {
  /**
   * Serializes OneStringProto2 to JSON.
   */
  encode: function (msg: PartialDeep<OneStringProto2>): string {
    return JSON.stringify(OneStringProto2JSON._writeMessage(msg));
  },

  /**
   * Deserializes OneStringProto2 from JSON.
   */
  decode: function (json: string): OneStringProto2 {
    return OneStringProto2JSON._readMessage(
      OneStringProto2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OneStringProto2 with all fields set to their default value.
   */
  initialize: function (): OneStringProto2 {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneStringProto2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneStringProto2, json: any): OneStringProto2 {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const ProtoWithKeywordsJSON = {
  /**
   * Serializes ProtoWithKeywords to JSON.
   */
  encode: function (msg: PartialDeep<ProtoWithKeywords>): string {
    return JSON.stringify(ProtoWithKeywordsJSON._writeMessage(msg));
  },

  /**
   * Deserializes ProtoWithKeywords from JSON.
   */
  decode: function (json: string): ProtoWithKeywords {
    return ProtoWithKeywordsJSON._readMessage(
      ProtoWithKeywordsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ProtoWithKeywords with all fields set to their default value.
   */
  initialize: function (): ProtoWithKeywords {
    return {
      inline: 0,
      concept: "",
      requires: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ProtoWithKeywords>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inline) {
      json["inline"] = msg.inline;
    }
    if (msg.concept) {
      json["concept"] = msg.concept;
    }
    if (msg.requires?.length) {
      json["requires"] = msg.requires;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ProtoWithKeywords,
    json: any,
  ): ProtoWithKeywords {
    const _inline_ = json["inline"];
    if (_inline_) {
      msg.inline = _inline_;
    }
    const _concept_ = json["concept"];
    if (_concept_) {
      msg.concept = _concept_;
    }
    const _requires_ = json["requires"];
    if (_requires_) {
      msg.requires = _requires_;
    }
    return msg;
  },
};

export const TestAllRequiredTypesProto2JSON = {
  /**
   * Serializes TestAllRequiredTypesProto2 to JSON.
   */
  encode: function (msg: PartialDeep<TestAllRequiredTypesProto2>): string {
    return JSON.stringify(TestAllRequiredTypesProto2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllRequiredTypesProto2 from JSON.
   */
  decode: function (json: string): TestAllRequiredTypesProto2 {
    return TestAllRequiredTypesProto2JSON._readMessage(
      TestAllRequiredTypesProto2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestAllRequiredTypesProto2 with all fields set to their default value.
   */
  initialize: function (): TestAllRequiredTypesProto2 {
    return {
      requiredInt32: 0,
      requiredInt64: 0n,
      requiredUint32: 0,
      requiredUint64: 0n,
      requiredSint32: 0,
      requiredSint64: 0n,
      requiredFixed32: 0,
      requiredFixed64: 0n,
      requiredSfixed32: 0,
      requiredSfixed64: 0n,
      requiredFloat: 0,
      requiredDouble: 0,
      requiredBool: false,
      requiredString: "",
      requiredBytes: new Uint8Array(),
      requiredNestedMessage:
        TestAllRequiredTypesProto2JSON.NestedMessage.initialize(),
      requiredForeignMessage: ForeignMessageProto2JSON.initialize(),
      requiredNestedEnum: TestAllRequiredTypesProto2.NestedEnum._fromInt(0),
      requiredForeignEnum: ForeignEnumProto2._fromInt(0),
      requiredStringPiece: "",
      requiredCord: "",
      recursiveMessage: undefined,
      optionalRecursiveMessage: undefined,
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllRequiredTypesProto2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredInt32) {
      json["requiredInt32"] = msg.requiredInt32;
    }
    if (msg.requiredInt64) {
      json["requiredInt64"] = msg.requiredInt64.toString();
    }
    if (msg.requiredUint32) {
      json["requiredUint32"] = msg.requiredUint32;
    }
    if (msg.requiredUint64) {
      json["requiredUint64"] = msg.requiredUint64.toString();
    }
    if (msg.requiredSint32) {
      json["requiredSint32"] = msg.requiredSint32;
    }
    if (msg.requiredSint64) {
      json["requiredSint64"] = msg.requiredSint64.toString();
    }
    if (msg.requiredFixed32) {
      json["requiredFixed32"] = msg.requiredFixed32;
    }
    if (msg.requiredFixed64) {
      json["requiredFixed64"] = msg.requiredFixed64.toString();
    }
    if (msg.requiredSfixed32) {
      json["requiredSfixed32"] = msg.requiredSfixed32;
    }
    if (msg.requiredSfixed64) {
      json["requiredSfixed64"] = msg.requiredSfixed64.toString();
    }
    if (msg.requiredFloat) {
      json["requiredFloat"] = msg.requiredFloat;
    }
    if (msg.requiredDouble) {
      json["requiredDouble"] = msg.requiredDouble;
    }
    if (msg.requiredBool) {
      json["requiredBool"] = msg.requiredBool;
    }
    if (msg.requiredString) {
      json["requiredString"] = msg.requiredString;
    }
    if (msg.requiredBytes?.length) {
      json["requiredBytes"] = encodeBase64Bytes(msg.requiredBytes);
    }
    if (msg.requiredNestedMessage) {
      const _requiredNestedMessage_ =
        TestAllRequiredTypesProto2JSON.NestedMessage._writeMessage(
          msg.requiredNestedMessage,
        );
      if (Object.keys(_requiredNestedMessage_).length > 0) {
        json["requiredNestedMessage"] = _requiredNestedMessage_;
      }
    }
    if (msg.requiredForeignMessage) {
      const _requiredForeignMessage_ = ForeignMessageProto2JSON._writeMessage(
        msg.requiredForeignMessage,
      );
      if (Object.keys(_requiredForeignMessage_).length > 0) {
        json["requiredForeignMessage"] = _requiredForeignMessage_;
      }
    }
    if (
      msg.requiredNestedEnum &&
      TestAllRequiredTypesProto2JSON.NestedEnum._toInt(msg.requiredNestedEnum)
    ) {
      json["requiredNestedEnum"] = msg.requiredNestedEnum;
    }
    if (
      msg.requiredForeignEnum &&
      ForeignEnumProto2JSON._toInt(msg.requiredForeignEnum)
    ) {
      json["requiredForeignEnum"] = msg.requiredForeignEnum;
    }
    if (msg.requiredStringPiece) {
      json["requiredStringPiece"] = msg.requiredStringPiece;
    }
    if (msg.requiredCord) {
      json["requiredCord"] = msg.requiredCord;
    }
    if (msg.recursiveMessage) {
      const _recursiveMessage_ = TestAllRequiredTypesProto2JSON._writeMessage(
        msg.recursiveMessage,
      );
      if (Object.keys(_recursiveMessage_).length > 0) {
        json["recursiveMessage"] = _recursiveMessage_;
      }
    }
    if (msg.optionalRecursiveMessage) {
      const _optionalRecursiveMessage_ =
        TestAllRequiredTypesProto2JSON._writeMessage(
          msg.optionalRecursiveMessage,
        );
      if (Object.keys(_optionalRecursiveMessage_).length > 0) {
        json["optionalRecursiveMessage"] = _optionalRecursiveMessage_;
      }
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllRequiredTypesProto2,
    json: any,
  ): TestAllRequiredTypesProto2 {
    const _requiredInt32_ = json["requiredInt32"] ?? json["required_int32"];
    if (_requiredInt32_) {
      msg.requiredInt32 = _requiredInt32_;
    }
    const _requiredInt64_ = json["requiredInt64"] ?? json["required_int64"];
    if (_requiredInt64_) {
      msg.requiredInt64 = BigInt(_requiredInt64_);
    }
    const _requiredUint32_ = json["requiredUint32"] ?? json["required_uint32"];
    if (_requiredUint32_) {
      msg.requiredUint32 = _requiredUint32_;
    }
    const _requiredUint64_ = json["requiredUint64"] ?? json["required_uint64"];
    if (_requiredUint64_) {
      msg.requiredUint64 = BigInt(_requiredUint64_);
    }
    const _requiredSint32_ = json["requiredSint32"] ?? json["required_sint32"];
    if (_requiredSint32_) {
      msg.requiredSint32 = _requiredSint32_;
    }
    const _requiredSint64_ = json["requiredSint64"] ?? json["required_sint64"];
    if (_requiredSint64_) {
      msg.requiredSint64 = BigInt(_requiredSint64_);
    }
    const _requiredFixed32_ =
      json["requiredFixed32"] ?? json["required_fixed32"];
    if (_requiredFixed32_) {
      msg.requiredFixed32 = _requiredFixed32_;
    }
    const _requiredFixed64_ =
      json["requiredFixed64"] ?? json["required_fixed64"];
    if (_requiredFixed64_) {
      msg.requiredFixed64 = BigInt(_requiredFixed64_);
    }
    const _requiredSfixed32_ =
      json["requiredSfixed32"] ?? json["required_sfixed32"];
    if (_requiredSfixed32_) {
      msg.requiredSfixed32 = _requiredSfixed32_;
    }
    const _requiredSfixed64_ =
      json["requiredSfixed64"] ?? json["required_sfixed64"];
    if (_requiredSfixed64_) {
      msg.requiredSfixed64 = BigInt(_requiredSfixed64_);
    }
    const _requiredFloat_ = json["requiredFloat"] ?? json["required_float"];
    if (_requiredFloat_) {
      msg.requiredFloat = _requiredFloat_;
    }
    const _requiredDouble_ = json["requiredDouble"] ?? json["required_double"];
    if (_requiredDouble_) {
      msg.requiredDouble = _requiredDouble_;
    }
    const _requiredBool_ = json["requiredBool"] ?? json["required_bool"];
    if (_requiredBool_) {
      msg.requiredBool = _requiredBool_;
    }
    const _requiredString_ = json["requiredString"] ?? json["required_string"];
    if (_requiredString_) {
      msg.requiredString = _requiredString_;
    }
    const _requiredBytes_ = json["requiredBytes"] ?? json["required_bytes"];
    if (_requiredBytes_) {
      msg.requiredBytes = decodeBase64Bytes(_requiredBytes_);
    }
    const _requiredNestedMessage_ =
      json["requiredNestedMessage"] ?? json["required_nested_message"];
    if (_requiredNestedMessage_) {
      TestAllRequiredTypesProto2JSON.NestedMessage._readMessage(
        msg.requiredNestedMessage,
        _requiredNestedMessage_,
      );
    }
    const _requiredForeignMessage_ =
      json["requiredForeignMessage"] ?? json["required_foreign_message"];
    if (_requiredForeignMessage_) {
      ForeignMessageProto2JSON._readMessage(
        msg.requiredForeignMessage,
        _requiredForeignMessage_,
      );
    }
    const _requiredNestedEnum_ =
      json["requiredNestedEnum"] ?? json["required_nested_enum"];
    if (_requiredNestedEnum_) {
      msg.requiredNestedEnum = _requiredNestedEnum_;
    }
    const _requiredForeignEnum_ =
      json["requiredForeignEnum"] ?? json["required_foreign_enum"];
    if (_requiredForeignEnum_) {
      msg.requiredForeignEnum = _requiredForeignEnum_;
    }
    const _requiredStringPiece_ =
      json["requiredStringPiece"] ?? json["required_string_piece"];
    if (_requiredStringPiece_) {
      msg.requiredStringPiece = _requiredStringPiece_;
    }
    const _requiredCord_ = json["requiredCord"] ?? json["required_cord"];
    if (_requiredCord_) {
      msg.requiredCord = _requiredCord_;
    }
    const _recursiveMessage_ =
      json["recursiveMessage"] ?? json["recursive_message"];
    if (_recursiveMessage_) {
      msg.recursiveMessage = TestAllRequiredTypesProto2JSON.initialize();
      TestAllRequiredTypesProto2JSON._readMessage(
        msg.recursiveMessage,
        _recursiveMessage_,
      );
    }
    const _optionalRecursiveMessage_ =
      json["optionalRecursiveMessage"] ?? json["optional_recursive_message"];
    if (_optionalRecursiveMessage_) {
      msg.optionalRecursiveMessage =
        TestAllRequiredTypesProto2JSON.initialize();
      TestAllRequiredTypesProto2JSON._readMessage(
        msg.optionalRecursiveMessage,
        _optionalRecursiveMessage_,
      );
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllRequiredTypesProto2.NestedEnum {
      switch (i) {
        case 0: {
          return "FOO";
        }
        case 1: {
          return "BAR";
        }
        case 2: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllRequiredTypesProto2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllRequiredTypesProto2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 0;
        }
        case "BAR": {
          return 1;
        }
        case "BAZ": {
          return 2;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllRequiredTypesProto2.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestAllRequiredTypesProto2JSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllRequiredTypesProto2.NestedMessage {
      return TestAllRequiredTypesProto2JSON.NestedMessage._readMessage(
        TestAllRequiredTypesProto2JSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.NestedMessage {
      return {
        a: 0,
        corecursive: undefined,
        optionalCorecursive: undefined,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.corecursive) {
        const _corecursive_ = TestAllRequiredTypesProto2JSON._writeMessage(
          msg.corecursive,
        );
        if (Object.keys(_corecursive_).length > 0) {
          json["corecursive"] = _corecursive_;
        }
      }
      if (msg.optionalCorecursive) {
        const _optionalCorecursive_ =
          TestAllRequiredTypesProto2JSON._writeMessage(msg.optionalCorecursive);
        if (Object.keys(_optionalCorecursive_).length > 0) {
          json["optionalCorecursive"] = _optionalCorecursive_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.NestedMessage,
      json: any,
    ): TestAllRequiredTypesProto2.NestedMessage {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _corecursive_ = json["corecursive"];
      if (_corecursive_) {
        msg.corecursive = TestAllRequiredTypesProto2JSON.initialize();
        TestAllRequiredTypesProto2JSON._readMessage(
          msg.corecursive,
          _corecursive_,
        );
      }
      const _optionalCorecursive_ =
        json["optionalCorecursive"] ?? json["optional_corecursive"];
      if (_optionalCorecursive_) {
        msg.optionalCorecursive = TestAllRequiredTypesProto2JSON.initialize();
        TestAllRequiredTypesProto2JSON._readMessage(
          msg.optionalCorecursive,
          _optionalCorecursive_,
        );
      }
      return msg;
    },
  },

  Data: {
    /**
     * Serializes TestAllRequiredTypesProto2.Data to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.Data>,
    ): string {
      return JSON.stringify(
        TestAllRequiredTypesProto2JSON.Data._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.Data from JSON.
     */
    decode: function (json: string): TestAllRequiredTypesProto2.Data {
      return TestAllRequiredTypesProto2JSON.Data._readMessage(
        TestAllRequiredTypesProto2JSON.Data.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.Data with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.Data {
      return {
        groupInt32: 0,
        groupUint32: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.Data>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupInt32) {
        json["groupInt32"] = msg.groupInt32;
      }
      if (msg.groupUint32) {
        json["groupUint32"] = msg.groupUint32;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.Data,
      json: any,
    ): TestAllRequiredTypesProto2.Data {
      const _groupInt32_ = json["groupInt32"] ?? json["group_int32"];
      if (_groupInt32_) {
        msg.groupInt32 = _groupInt32_;
      }
      const _groupUint32_ = json["groupUint32"] ?? json["group_uint32"];
      if (_groupUint32_) {
        msg.groupUint32 = _groupUint32_;
      }
      return msg;
    },
  },

  MessageSetCorrect: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrect to JSON.
     */
    encode: function (
      _msg?: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrect>,
    ): string {
      return "{}";
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrect from JSON.
     */
    decode: function (
      _json?: string,
    ): TestAllRequiredTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrect with all fields set to their default value.
     */
    initialize: function (): TestAllRequiredTypesProto2.MessageSetCorrect {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrect>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.MessageSetCorrect,
      _json: any,
    ): TestAllRequiredTypesProto2.MessageSetCorrect {
      return msg;
    },
  },

  MessageSetCorrectExtension1: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension1>,
    ): string {
      return JSON.stringify(
        TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension1._writeMessage(
          msg,
        ),
      );
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 from JSON.
     */
    decode: function (
      json: string,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
      return TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension1._readMessage(
        TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension1.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrectExtension1 with all fields set to their default value.
     */
    initialize:
      function (): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
        return {
          str: "",
        };
      },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension1>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.str) {
        json["str"] = msg.str;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.MessageSetCorrectExtension1,
      json: any,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension1 {
      const _str_ = json["str"];
      if (_str_) {
        msg.str = _str_;
      }
      return msg;
    },
  },

  MessageSetCorrectExtension2: {
    /**
     * Serializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 to JSON.
     */
    encode: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension2>,
    ): string {
      return JSON.stringify(
        TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension2._writeMessage(
          msg,
        ),
      );
    },

    /**
     * Deserializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 from JSON.
     */
    decode: function (
      json: string,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
      return TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension2._readMessage(
        TestAllRequiredTypesProto2JSON.MessageSetCorrectExtension2.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllRequiredTypesProto2.MessageSetCorrectExtension2 with all fields set to their default value.
     */
    initialize:
      function (): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
        return {
          i: 0,
        };
      },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllRequiredTypesProto2.MessageSetCorrectExtension2>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.i) {
        json["i"] = msg.i;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllRequiredTypesProto2.MessageSetCorrectExtension2,
      json: any,
    ): TestAllRequiredTypesProto2.MessageSetCorrectExtension2 {
      const _i_ = json["i"];
      if (_i_) {
        msg.i = _i_;
      }
      return msg;
    },
  },
};
